# 事件分类

MotionEvent总共有四种事件类型，分别是ACTION_DOWN、ACTION_MOVE、ACTION_UP、ACTION_CANCEL

一般情况下，一次触摸过程，会经历ACTION_DOWN，多个ACTION_MOVE（0~N），ACTION_UP

- ACTION_DOWN
- ACTION_MOVE
- ACTION_UP
- ACTION_CANCEL


# 简要总结

- 事件分发的传递顺序为：Activity---ViewGroup---View

# 多控件间的滑动问题

例如，有上下两个ScrollView，如果手指一直按在下面的ScrollView，并持续滑动，如果滑动至上面的ScrollView，结果是下面的ScrollView还在滑动

原因：ViewGroup.dispatchTouchEvent中，会把事件分发给所有的子视图，寻找可以获取焦点的视图，当发生抬起或取消事件，更新触摸targets

# 从点击屏幕到事件分发

1. 由底层触发InputChannel传递给ActivityThread,由ActivityThread交给WindowInputEventReceiver,再由ViewRootImpl用InputStage处理分发输入事件
2. View.dispatchPointerEvent
3. PhoneWindow.DecorView.dispatchTouchEvent()
4. Activity.dispatchTouchEvent()
5. PhoneWindow.superDispatchTouchEvent()
6. PhoneWindow.DecorView.superDispatchTouchEvent()
7. ViewGroup.dispatchTouchEvent()

从这里看出，如果是从点击屏幕开始算起，事件分发的流程应该是View---ViewGroup---Activity---ViewGroup---View，但一般的事件分发，都是从Activity的dispatchTouchEvent方法开始说起的

# 记录

* DOWN - MOVE（0---无数次）- UP
* Activity - ViewGroup - View
* 三个方法
    * dispatchTouchEvent() 当事件能够传递至该View时，触发此方法
    * onInterceptTouchEvent() 在dispatchTouchEvent内部调用，用于判断是否拦截某个事件，只存在于ViewGroup
    * onTouchEvent() 在dispatchTouchEvent内部调用，用于处理事件
* dispatchTouchEvent返回值处理如下
    * true 直接结束，后续事件会传递至该view，注意，此时不会执行onTouchEvent方法
    * false 不处理，会返回至上一层的onTouchEvent，如果上一层是第一层，则直接消费
    * super 如果是第一层，直接传至下一层，如果是其他层，则执行本层的onInterceptTouchEvent或onTouchEvent
* onInterceptTouchEvent返回值处理如下
    * true 本层消费，接着执行本层的onTouchEvent 
    * false 向下传递
    * super 向下传递
* onTouchEvent
    * true 直接消费
    * false 返回至上一层的onTouchEvent，当前View不再接受此事件列的其他事件（Move、Up）
    * super 返回至上一层的onTouchEvent，当前View不再接受此事件列的其他事件（Move、Up）
* 三种返回
    * super：调用父类方法
    * true：消费事件，即事件不继续往下传递
    * false：不消费事件，事件也不继续往下传递 / 交由给父控件onTouchEvent（）处理 
* onInterceptTouchEvent方法，该方法一旦返回一次true，就再也不会被调用了，即使是执行true，也不是消费事件，而是分发事件至onTouchEvent
* onTouch优先于onTouchEvent执行，如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现
* dispatchTouchEvent()和 onTouchEvent()消费事件、终结事件传递（返回true）
  而onInterceptTouchEvent 并不能消费事件，它相当于是一个分叉口起到分流导流的作用，对后续的ACTION_MOVE和ACTION_UP事件接收起到非常大的作用
* ViewGroup拦截DOWN的后续事件(如MOVE)，DOWN会直接传递给View，第一个MOVE，会变成CANCEL事件传递给View，后续的MOVE，传递至ViewGroup的onTouchEvent事件中
* 点击事件分发过程如下
    * dispatchTouchEvent
    * OnTouchListener的onTouch方法
    * onTouchEvent
    * OnClickListener的onClick方法

# 参考资料

* [Android事件分发机制 详解攻略，您值得拥有](http://blog.csdn.net/carson_ho/article/details/54136311)
* [http://gityuan.com/2015/09/19/android-touch/](http://gityuan.com/2015/09/19/android-touch/)
* [Android触摸屏事件派发机制详解与源码分析二(ViewGroup篇)](https://blog.csdn.net/yanbober/article/details/45912661)
* [从点击屏幕到事件处理的事件分发源码流程](https://juejin.im/post/5a0141a9518825603b585740)