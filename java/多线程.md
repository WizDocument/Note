# synchronized&volatile&AtomicInteger的区别

volatile不能保证原子性，例如，当两个线程T1,T2同时对volatitle int i;作i++;时，可能出现问题。i++相当于为i=i+1。

T1 LOAD i
T2 LOAD i
T1 STORE i+1
T2 STORE i+1

这里应该执行两次i=i+1，得到i=i+2的，但是结果确实i=i+1。

AtomicInteger（java.util.concurrent.atomic.Atomic*原子类）能保证原子性

总结说来

- synchronized 实现的同步能确保线程安全，实现可见性和原子性；但是代价大，效率低，更慢；
- volatile 能够实现多线程操作产生变化的可见性，但是不能实现原子性。
- atomic 类 是一种更轻量级的方法实现可见性和原子性

# int是否线程安全

不是线程安全的，AtomicInteger是线程安全的类，比synchronized效率高

AtomicInteger内部存在Unsafe类、volatile类

AtomicInteger中用的就是Unsafe的CAS操作。CAS操作可以实现非阻塞的原子操作，但是会产生ABA问题

CAS：对于内存中的某一个值V，提供一个旧值A和一个新值B。如果提供的旧值V和A相等就把B写入V。这个过程是原子性的。CAS执行结果要么成功要么失败，对于失败的情形下一班采用不断重试。或者放弃。简单来说，CAS 的含义是 “我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”

ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。

# volatile

JVM中所有的变量都保存在主存中，每个Thread有自己的工作内存，读写变量时，需要从主存中读取变量，然后在自己的工作内存中完成修改，再同步回主存

线程同步的三个特性

- 原子性：当前操作不可中断
- 可见性：
- 有序性：指令重排

[volatile面试问题](https://juejin.im/post/5a2b53b7f265da432a7b821c)

# 延迟启动子线程

```
new Handler().postDelayed(new Runnable() {
    @Override
    public void run() {
        skip();
    }
}, 1000);
```

# Android中启动子线程的方法

方法一

```
new Thread(new Runnable() {
            @Override
            public void run() {

            }
        }).start();
```

优点：简单
缺点：Runnable是匿名内部类，线程执行完之前持有外部类的引用，这段时间内会造成内存泄漏

如果从UI线程启动，则该线程优先级默认为Default，归于default cgroup，会平等的和UI线程争夺CPU资源。这一点尤其需要注意，在对UI性能要求高的场景下要记得

```
new Thread(new Runnable() {
			@Override
			public void run() {
				Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
			}
		}).start();
```

虽说处于background group的线程总共只能争取到5～10%的CPU资源，但这对绝大部分的后台任务处理都绰绰有余了，1ms和10ms对用户来说，都是快到无法感知，所以我们一般都偏向于在background group当中执行工作线程任务。

方法二：AsyncTask

TODO

# 如何停止子线程？

TODO

添加标志位